---
eip: 7851
title: Deactivate a Delegated EOA's Key
description: Introduce a new precompiled contract for EOAs with delegated code to permanently deactivate private keys.
author: Liyi Guo (@colinlyguo), Nicolas Consigny (@nconsigny)
discussions-to: https://ethereum-magicians.org/t/eip-7851-deactivate-reactivate-a-delegated-eoas-key/22344
status: Stagnant
type: Standards Track
category: Core
created: 2024-12-27
requires: 7702
---

## Abstract

This EIP introduces a precompiled contract that enables Externally Owned Accounts (EOAs) with delegated control to smart contracts via [EIP-7702](./eip-7702) to permanently deactivate their private keys. This is a one-way migration designed for post-quantum security—once deactivated, an EOA's ECDSA key cannot be reactivated in-protocol. The design supports an optional time-delayed deactivation mechanism, allowing users to specify a delay period during which the deactivation can be cancelled via an ECDSA-signed transaction. Delayed deactivation requires tracking a per-account finalization timestamp; immediate deactivation is encoded solely in the delegated code.

## Motivation

[EIP-7702](./eip-7702) enables EOAs to gain smart contract capabilities, but the private key of the EOA still retains full control over the account.

With this EIP, EOAs can fully migrate to smart contract wallets via a one-way deactivation of ECDSA keys. This approach is designed with post-quantum security in mind—once a quantum attacker becomes viable, allowing reactivation of ECDSA keys would defeat the purpose of the migration. By making deactivation permanent and irreversible at the protocol level, users gain strong guarantees that their accounts cannot be compromised by future quantum attacks on ECDSA.

The time-delayed deactivation option provides a safety mechanism: users can specify a delay period (e.g., N days) before deactivation becomes final, during which they can cancel via an ECDSA-signed transaction if they change their mind or detect an unauthorized deactivation attempt.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Parameters

| Constant                          | Value                |
|-----------------------------------|----------------------|
| `PRECOMPILE_ADDRESS`              | `0xTBD`              |
| `PRECOMPILE_GAS_COST`             | `13000`              |
| `CANCEL_PRECOMPILE_ADDRESS`       | `0xTBD`              |
| `CANCEL_PRECOMPILE_GAS_COST`      | `13000`              |
| `SECONDS_PER_DAY`                 | `86400`              |

### Definitions

* `||` is the byte/byte-array concatenation operator.
* `deactivation_finalization_timestamp` is an optional per-account uint32 timestamp (seconds since Unix epoch) that specifies when a delayed deactivation becomes final. If unset, no delayed deactivation is scheduled.

### Delegated Code Encoding

The deactivation status is encoded by appending a `0x00` byte at the end of the delegated code. The encoding is as follows:

* Active state: `0xef0100 || address` (23 bytes). The private key is active and can sign transactions.
* Deactivated state: `0xef0100 || address || 0x00` (24 bytes). The private key is permanently deactivated and cannot sign transactions or [EIP-7702](./eip-7702) delegation authorizations.

Note: Deactivation is **irreversible** at the protocol level. There is no in-protocol reactivation mechanism.
Delayed deactivation does not change the delegated code until finalization; the finalization timestamp is tracked separately.

### Client Code Recognition

Clients MUST recognize `0xef0100 || address || 0x00` as a valid delegated + deactivated account. The trailing `0x00` byte MUST be ignored for execution purposes—the EVM MUST still jump to `address` for code execution. This ensures that deactivated EOAs retain their delegated contract functionality.

### Deactivation Precompiled Contract

A new precompiled contract is introduced at address `PRECOMPILE_ADDRESS`. It costs `PRECOMPILE_GAS_COST` and executes the following logic:

* Input: Optional 4-byte `delay_days` (big-endian uint32). If omitted or zero, immediate deactivation.
* Returns a precompile contract error, consumes all gas, and no state changes are made if:
  * Gas is insufficient.
  * Called via `STATICCALL` (i.e., in a read-only context).
  * Caller is not an EOA with delegated code (prefix `0xef0100` as per [EIP-7702](./eip-7702)).
  * Caller's code length is not `23` bytes (already deactivated).
  * A delayed deactivation is already scheduled for the caller (i.e., `deactivation_finalization_timestamp` is set).
* Behavior:
  * If `delay_days == 0` or no input: Appends `0x00` to immediately deactivate (`23` -> `24` bytes) and clears any existing `deactivation_finalization_timestamp`.
  * If `delay_days > 0`: Computes `finalization_timestamp = block.timestamp + (delay_days * SECONDS_PER_DAY)` and sets `deactivation_finalization_timestamp` for the caller. The delegated code remains `23` bytes until finalization.
* Saves updated code (if modified) as caller's new account code.

### Cancellation Precompiled Contract

A new precompiled contract is introduced at address `CANCEL_PRECOMPILE_ADDRESS`. It costs `CANCEL_PRECOMPILE_GAS_COST` and allows cancellation of delayed deactivations:

* Returns a precompile contract error, consumes all gas, and no state changes are made if:
  * Gas is insufficient.
  * Called via `STATICCALL` (i.e., in a read-only context).
  * Caller is not an EOA with delegated code (prefix `0xef0100` as per [EIP-7702](./eip-7702)).
  * No delayed deactivation is scheduled for the caller (i.e., `deactivation_finalization_timestamp` is unset).
  * `block.timestamp >= deactivation_finalization_timestamp` (deactivation already finalized).
* Behavior:
  * Clears `deactivation_finalization_timestamp`, leaving the delegated code in the active 23-byte form.
* Saves updated code (if modified) as caller's new account code.

### Finalization of Delayed Deactivations

For accounts with a scheduled delayed deactivation (`deactivation_finalization_timestamp` set):

* During transaction validation, if `block.timestamp >= deactivation_finalization_timestamp`, the account MUST be treated as deactivated.
* Implementations MAY lazily append `0x00` to the delegated code and clear `deactivation_finalization_timestamp` upon the next state access, or MAY perform this conversion eagerly at block processing time.

### Transaction Validation

An account is considered deactivated if:
* Code prefix is `0xef0100` AND code length is `24` bytes, OR
* Code prefix is `0xef0100` AND `deactivation_finalization_timestamp` is set AND `block.timestamp >= deactivation_finalization_timestamp`

Validation to check whether a private key is deactivated MUST be performed in the following scenarios:

* During transaction validity checks before execution, nodes MUST reject transactions signed with deactivated private keys to ensure such transactions cannot be included in blocks.
* The same validation MUST be applied to the transaction pool when receiving new transactions to prevent invalid transactions from propagating through the network.
* Any [EIP-7702](./eip-7702) authorization issued by an authority with a deactivated private key MUST be treated as invalid and skipped.

### Mempool Behavior

Mempool implementations MUST adhere to the following rules:

* **Rejection of new transactions**: The mempool MUST reject newly received transactions from senders whose accounts are deactivated at the current head.
* **Eviction of existing transactions**: The mempool SHOULD evict already pooled transactions from a sender once that sender is observed deactivated at the current head.
* **Revalidation timing**: Mempool implementations MUST revalidate pooled transactions against the current head state on head changes. This MAY be done either:
  * Eagerly for affected senders upon head change, OR
  * Lazily when selecting transactions for propagation or block inclusion.

### Reorg Handling

On chain reorganization:

* The mempool SHOULD revalidate pooled transactions against the new head state.
* Transactions previously dropped due to deactivation MAY be re-accepted if re-gossiped after a reorg that undoes the deactivation.
* Implementations are NOT REQUIRED to retain transactions that became invalid due to deactivation across head changes—such transactions may need to be re-gossiped to re-enter the pool.

### Wallet and Indexer Parsing

Wallets and indexers SHOULD parse delegated EOA code as follows:

```python
def parse_delegated_eoa(code: bytes) -> dict:
    """
    Parse delegated EOA code to determine status.

    Returns:
        dict with keys:
        - 'is_delegated': bool
        - 'delegate_address': bytes or None
        - 'status': 'active' | 'deactivated' | 'unknown'
    """
    DELEGATION_PREFIX = bytes.fromhex("ef0100")

    if not code.startswith(DELEGATION_PREFIX):
        return {
            'is_delegated': False,
            'delegate_address': None,
            'status': 'unknown'
        }

    if len(code) == 23:
        # Active: 0xef0100 || address (20 bytes)
        return {
            'is_delegated': True,
            'delegate_address': code[3:23],
            'status': 'active'
        }
    elif len(code) == 24:
        # Deactivated: 0xef0100 || address || 0x00
        return {
            'is_delegated': True,
            'delegate_address': code[3:23],
            'status': 'deactivated'
        }
    else:
        return {
            'is_delegated': True,
            'delegate_address': code[3:23],
            'status': 'unknown'
        }
```

## Rationale

### Cost of Precompiled Contracts

The `PRECOMPILE_GAS_COST` represents the gas required to validate and potentially update an account's code. A fair cost for calling this precompiled contract can be determined by analyzing its impact on the node:

* Reading the code of the address: `2600`.
* Changing the code hash (from non-zero to non-zero): `5000`.
* Deploying at most `24` bytes of code: `200 * 24 = 4800`.

The primary operation consumes a total of `12400` gas, rounded up to `13000`. The same cost applies to the cancellation precompile as the operations are symmetric.

### Additional Transaction Validation Overhead

Due to [EIP-3607](./eip-3607) and [EIP-7702](./eip-7702), nodes already load the account code during transaction validation to verify whether the sender is an EOA (empty code or code with prefix `0xef0100`). This EIP introduces only a code length check (and, when a delayed deactivation is scheduled, a timestamp check), resulting in minimal additional overhead. Similarly, [EIP-7702](./eip-7702)’s authorization validation already involves retrieving the account code, with this EIP adding only a code length check and an optional timestamp check, which is negligible compared to code reading.

Transaction pools already perform state-based checks, such as those for nonce and balance. This EIP adds an account code read and a length check, which together are comparable to nonce and balance validations. DoS prevention mechanisms, expected in transaction pools, also support these additional checks.

### An Alternative EOA Deprecation Approach

An alternative deprecation approach involves using a hard fork to edit all existing and new EOAs to pre-written upgradeable smart contracts, which utilize the original EOA private key for authorization. Users can add and replace keys, or upgrade the smart contracts to other implementations. However, this approach is incompatible with EOAs already delegated to smart contracts, as it will overwrite the existing smart contract implementations. This EIP aims to fill this migration gap.

### Using a Precompiled Contract

Alternative methods for deactivating EOA private keys include:

* Adding a new transaction type: Introducing a new transaction type could provide a mechanism to deactivate EOA private keys. However, this adds complexity to transaction processing and validation.
* Deploying a smart contract: Compared to reusing the code field, using a smart contract has higher costs: (i) it requires new contract storage slots to track the deactivation status of each address (ii) executing bytecode increases the overhead of the node compared to precompiled contracts, (iii) during transaction validation, reusing the code field allows deactivation status check to be combined with existing code loading in some scenarios, thereby reducing the need for additional storage reads, as discussed in [Additional Transaction Validation Overhead](#additional-transaction-validation-overhead) section.

### One-Way Migration (No In-Protocol Reactivation)

This EIP intentionally does NOT provide an in-protocol reactivation mechanism. The rationale is:

* **Post-quantum security**: If a quantum attacker becomes viable, allowing ECDSA key reactivation would defeat the purpose of migration. A one-way deactivation provides strong guarantees against future quantum attacks.
* **Simplicity**: Removing reactivation significantly simplifies the protocol. Reactivation would require additional security measures at the delegated contract level to prevent unauthorized reactivation, which increases attack surface.
* **Clear security model**: Users have certainty that once deactivated, their ECDSA key cannot be used—even if the delegated contract is compromised in a way that would allow reactivation.

The time-delayed deactivation mechanism provides a safety window for users who may have triggered deactivation accidentally or who detect an unauthorized deactivation attempt. During the delay period, the original ECDSA key can still cancel the delayed deactivation.

### Avoiding Delegated Code Prefix Modification

This EIP appends a byte (`0x00`) to the delegated code instead of modifying the prefix (`0xef0100`) of [EIP-7702](./eip-7702) to ensure forward compatibility. If new prefixes such as `0xef0101` are introduced in the future, changing the prefix to represent the deactivated status (e.g., `0xef01ff`) makes it unclear which prefix to restore (`0xef0100` or `0xef0101`) upon reactivation.

### Minimal Account State Changes

This EIP avoids adding a permanent `deactivated` field to all accounts. The final deactivated state is encoded in the delegated code (`0xef0100 || address || 0x00`), and the only additional state is an optional `deactivation_finalization_timestamp` used solely for delayed deactivation. This keeps backward compatibility logic and new test vectors minimal.

## Backwards Compatibility

When the private key is deactivated, this EIP introduces an additional `0x00` byte appended to the end of the delegated code, and the delegated code length becomes `24` bytes (deactivated). Delayed deactivation does not change the delegated code until finalization.

These changes are not breaking. However, they require protocol, application, and contract implementations to:

* Use strict offsets (bytes 3-22) to parse the delegated address correctly, ignoring the trailing byte.
* Check the delegated code prefix `0xef0100` to determine whether it represents an EOA with delegated code.
* Avoid over-restrictive checks, such as asserting the code length to be exactly `23`.
* Recognize that code lengths of `23` and `24` bytes are valid delegated EOA states.

Clients MUST still jump to the delegated address for execution even when the trailing byte is present—the deactivation status only affects ECDSA signing authority, not contract execution.

## Test Cases

```python
import time

# Initialize the state database and precompiled contracts
state_db = StateDB()
deactivate_precompile = DeactivationPrecompile()
cancel_precompile = CancellationPrecompile()

# Test 1: Immediate deactivation (no delay)
caller = "0x0123"
delegated_addr = bytes.fromhex("1122334455667788990011223344556677889900")
active_code = DeactivationPrecompile.DELEGATED_CODE_PREFIX + delegated_addr  # Active state (23 bytes)

state_db.set_code(caller, active_code)
error, gas_left = deactivate_precompile.execute(caller, state_db, gas=15000, input_data=b"")
assert error == b""
assert state_db.get_code(caller) == active_code + b"\x00"  # Deactivated state (24 bytes)
assert gas_left == 15000 - DeactivationPrecompile.PRECOMPILE_GAS_COST

# Test 2: Cannot deactivate already deactivated account
error, gas_left = deactivate_precompile.execute(caller, state_db, gas=15000, input_data=b"")
assert error == b"account is not in active state"
assert gas_left == 0

# Test 3: Delayed deactivation (7 days)
caller2 = "0x4567"
state_db.set_code(caller2, active_code)
delay_days = (7).to_bytes(4, 'big')  # 7 days
current_timestamp = 1700000000
error, gas_left = deactivate_precompile.execute(
    caller2, state_db, gas=15000, input_data=delay_days, block_timestamp=current_timestamp
)
assert error == b""
expected_timestamp = current_timestamp + (7 * 86400)
assert state_db.get_code(caller2) == active_code  # Still active during delay
assert state_db.get_deactivation_timestamp(caller2) == expected_timestamp

# Test 4: Cancel delayed deactivation
error, gas_left = cancel_precompile.execute(
    caller2, state_db, gas=15000, block_timestamp=current_timestamp + 1000
)
assert error == b""
assert state_db.get_deactivation_timestamp(caller2) is None
assert state_db.get_code(caller2) == active_code  # Back to active state (23 bytes)

# Test 5: Deactivation finalizes after delay
caller3 = "0x89ab"
state_db.set_code(caller3, active_code)
deactivate_precompile.execute(
    caller3, state_db, gas=15000, input_data=delay_days, block_timestamp=current_timestamp
)
finalization_timestamp = state_db.get_deactivation_timestamp(caller3)
assert is_account_deactivated(state_db.get_code(caller3), finalization_timestamp - 1, finalization_timestamp) is False
assert is_account_deactivated(state_db.get_code(caller3), finalization_timestamp + 1, finalization_timestamp) is True

# Test 6: Cannot cancel after finalization
error, gas_left = cancel_precompile.execute(
    caller3, state_db, gas=15000, block_timestamp=finalization_timestamp + 1  # After finalization
)
assert error == b"deactivation already finalized"
assert gas_left == 0

# Test 7: Error cases
caller4 = "0xcdef"  # EOA that is not delegated to code
error, gas_left = deactivate_precompile.execute(caller4, state_db, gas=15000, input_data=b"")
assert error == b"the address is not an EOA delegated to code"
assert gas_left == 0

error, gas_left = deactivate_precompile.execute(caller, state_db, gas=15000, read_only=True)
assert error == b"STATICCALL disallows state modification"
assert gas_left == 0

error, gas_left = deactivate_precompile.execute(
    caller, state_db, gas=DeactivationPrecompile.PRECOMPILE_GAS_COST - 1
)
assert error == b"insufficient gas"
assert gas_left == 0
```

## Reference Implementation

```python
class DeactivationPrecompile:
    DELEGATED_CODE_PREFIX = bytes.fromhex("ef0100")
    PRECOMPILE_GAS_COST = 13000
    SECONDS_PER_DAY = 86400

    def execute(self, caller, state_db, gas, input_data=b"", read_only=False, block_timestamp=0):
        """
        Deactivate the private key of a delegated EOA, optionally with a time delay.

        Parameters:
        - caller: The address calling the contract
        - state_db: The state database
        - gas: Gas provided for execution
        - input_data: Optional 4-byte delay_days (big-endian uint32)
        - read_only: Whether called in a read-only context
        - block_timestamp: Current block timestamp

        Returns:
        - Tuple of (result, gas_left)
          result: error bytes on failure, empty bytes on success
          gas_left: remaining gas, 0 on error
        """
        if gas < self.PRECOMPILE_GAS_COST:
            return b"insufficient gas", 0

        if read_only:
            return b"STATICCALL disallows state modification", 0

        code = state_db.get_code(caller)
        if not code.startswith(self.DELEGATED_CODE_PREFIX):
            return b"the address is not an EOA delegated to code", 0

        if len(code) != 23:
            return b"account is not in active state", 0

        existing_finalization_timestamp = state_db.get_deactivation_timestamp(caller)
        if existing_finalization_timestamp is not None:
            if block_timestamp >= existing_finalization_timestamp:
                return b"account is not in active state", 0
            return b"account already has a scheduled deactivation", 0

        # Parse delay_days from input
        delay_days = 0
        if len(input_data) >= 4:
            delay_days = int.from_bytes(input_data[:4], 'big')

        if delay_days == 0:
            # Immediate deactivation
            state_db.set_code(caller, code + b"\x00")
            state_db.clear_deactivation_timestamp(caller)
        else:
            # Delayed deactivation
            finalization_timestamp = block_timestamp + (delay_days * self.SECONDS_PER_DAY)
            state_db.set_deactivation_timestamp(caller, finalization_timestamp)

        return b"", gas - self.PRECOMPILE_GAS_COST


class CancellationPrecompile:
    DELEGATED_CODE_PREFIX = bytes.fromhex("ef0100")
    PRECOMPILE_GAS_COST = 13000

    def execute(self, caller, state_db, gas, read_only=False, block_timestamp=0):
        """
        Cancel a delayed deactivation of a delegated EOA.

        Parameters:
        - caller: The address calling the contract
        - state_db: The state database
        - gas: Gas provided for execution
        - read_only: Whether called in a read-only context
        - block_timestamp: Current block timestamp

        Returns:
        - Tuple of (result, gas_left)
          result: error bytes on failure, empty bytes on success
          gas_left: remaining gas, 0 on error
        """
        if gas < self.PRECOMPILE_GAS_COST:
            return b"insufficient gas", 0

        if read_only:
            return b"STATICCALL disallows state modification", 0

        code = state_db.get_code(caller)
        if not code.startswith(self.DELEGATED_CODE_PREFIX):
            return b"the address is not an EOA delegated to code", 0

        finalization_timestamp = state_db.get_deactivation_timestamp(caller)
        if finalization_timestamp is None:
            return b"account has no scheduled deactivation", 0

        # Check if deactivation has already finalized
        if block_timestamp >= finalization_timestamp:
            return b"deactivation already finalized", 0

        # Cancel: clear the scheduled deactivation
        state_db.clear_deactivation_timestamp(caller)

        return b"", gas - self.PRECOMPILE_GAS_COST


class StateDB:
    """Simplified state database, omitting other account fields"""
    def __init__(self):
        self.accounts = {}

    def get_code(self, addr):
        return self.accounts.get(addr, {}).get("code", b"")

    def set_code(self, addr, value):
        if addr not in self.accounts:
            self.accounts[addr] = {}
        self.accounts[addr]["code"] = value

    def get_deactivation_timestamp(self, addr):
        return self.accounts.get(addr, {}).get("deactivation_finalization_timestamp")

    def set_deactivation_timestamp(self, addr, value):
        if addr not in self.accounts:
            self.accounts[addr] = {}
        self.accounts[addr]["deactivation_finalization_timestamp"] = value

    def clear_deactivation_timestamp(self, addr):
        if addr in self.accounts:
            self.accounts[addr].pop("deactivation_finalization_timestamp", None)


def is_account_deactivated(code: bytes, block_timestamp: int, finalization_timestamp: int | None = None) -> bool:
    """
    Check if an account is deactivated based on its code and current timestamp.

    Parameters:
    - code: The account's code
    - block_timestamp: Current block timestamp
    - finalization_timestamp: Optional delayed deactivation timestamp

    Returns:
    - True if deactivated, False otherwise
    """
    DELEGATED_CODE_PREFIX = bytes.fromhex("ef0100")

    if not code.startswith(DELEGATED_CODE_PREFIX):
        return False

    if len(code) == 24:
        # Immediately deactivated
        return True
    elif len(code) == 23 and finalization_timestamp is not None:
        # Delayed deactivation - check if finalized
        return block_timestamp >= finalization_timestamp

    return False
```

## Security Considerations

### Contracts Using ECDSA `Secp256k1` Signatures

Contracts that have already been deployed and use ECDSA `secp256k1` signatures outside of transaction signatures (e.g., [ERC-20](./eip-20) tokens that support [ERC-2612](./eip-2612), the `permit` function) will not be able to verify the deactivated status of the EOA. This means that signatures signed by private keys will remain valid in these functions.

To handle deactivated EOAs, new or upgradeable contracts can check the signing address's deactivation status, for example:

* Use `EXTCODESIZE` to get the account's code length.
* If the code length is `24` bytes, use `EXTCODECOPY` to verify the code starts with `0xef0100` (delegated code prefix).
* For 24-byte code: the account is deactivated.

Delayed deactivation scheduling is not encoded in the delegated code, so contracts cannot detect a scheduled (but not yet finalized) deactivation without additional protocol support.

For non-upgradeable contracts, the above method cannot be applied directly. Another potential solution, at the protocol level, is to modify `ecRecover` precompiled contract: if the private key of the recovered address is deactivated, the `ecRecover` precompiled contract could return a precompile contract error (or, if not adding an error return path, return a zero address or a collision-resistant address, such as `0x1`). However, this approach also has limitations, as it cannot cover cases where contracts implement their own signature verification logic without relying on `ecRecover`.

### Irreversible Deactivation by Design

Deactivation is intentionally irreversible at the protocol level to provide post-quantum security guarantees. Users should understand that once deactivated (and any delay period has passed), their ECDSA key cannot be reactivated. The time-delayed deactivation option provides a safety window for users to cancel if needed.

### Time-Delayed Deactivation Security

The time-delayed deactivation mechanism introduces additional considerations:

* **Cancellation window**: During the delay period, the original ECDSA key can cancel the deactivation. This is intentional—it provides a safety mechanism against unauthorized deactivation attempts.
* **Malicious cancellation**: If an attacker has access to the ECDSA key during the delay period, they can cancel the deactivation. Users who suspect key compromise should use immediate deactivation (zero delay) rather than time-delayed deactivation.
* **Timestamp manipulation**: The finalization timestamp uses `block.timestamp`. Validators have limited ability to manipulate timestamps, bounded by protocol rules. The delay should be chosen to be long enough that minor timestamp variations are insignificant.

### Deactivation Replay Protection

For deactivation through EOA-signed transactions, the use of nonces in transactions ensures the same message cannot be replayed multiple times on the same chain. Additionally, the replay protection mechanism provided by [EIP-155](./eip-155), if enabled, effectively prevents cross-chain message replay.

For deactivation via delegated contracts, the contract should implement robust replay protection mechanism(s) (e.g., adding a customized nonce and the chain ID to the signed message) to safeguard against replay attacks both within the same chain and across different chains.

### Mempool and Reorg Considerations

* **Mempool eviction timing**: Implementations should be aware that evicting transactions immediately upon deactivation may cause issues if the deactivation is reverted in a reorg. The SHOULD (rather than MUST) language for eviction provides flexibility.
* **Revalidation overhead**: Frequent head changes require revalidation. Implementations should balance thoroughness with performance.
* **Delayed deactivation edge cases**: Transactions from accounts with a scheduled delayed deactivation remain valid until `block.timestamp >= deactivation_finalization_timestamp`. Implementations must track this correctly across block boundaries.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
