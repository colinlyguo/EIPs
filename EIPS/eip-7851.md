---
eip: 7851
title: Deactivate a Delegated EOA's Key
description: Introduce a new precompiled contract for EOAs with delegated code to permanently deactivate private keys.
author: Liyi Guo (@colinlyguo), Nicolas Consigny (@nconsigny)
discussions-to: https://ethereum-magicians.org/t/eip-7851-deactivate-reactivate-a-delegated-eoas-key/22344
status: Stagnant
type: Standards Track
category: Core
created: 2024-12-27
requires: 7702, XXXX
---

## Abstract

This EIP introduces a precompiled contract that enables Externally Owned Accounts (EOAs) with delegated control to smart contracts via [EIP-7702](./eip-7702) to permanently deactivate their private keys. This is a one-way migration designed for post-quantum security—once deactivated, an EOA's ECDSA key cannot be reactivated in-protocol. Deactivation has a 7-day delay period during which it can be cancelled via an ECDSA-signed transaction, providing a safety mechanism against unauthorized deactivation attempts.

## Motivation

[EIP-7702](./eip-7702) enables EOAs to gain smart contract capabilities, but the private key of the EOA still retains full control over the account.

With this EIP, EOAs can fully migrate to smart contract wallets via a one-way deactivation of ECDSA keys. This approach is designed with post-quantum security in mind once a quantum attacker becomes viable, allowing reactivation of ECDSA keys would defeat the purpose of the migration. By making deactivation permanent and irreversible at the protocol level, users gain strong guarantees that their accounts cannot be compromised by future quantum attacks on ECDSA. This also paves the way for a migration from EOA toward smart contract with native account abstraction. e.g., [EIP-8141](./eip-8141).

The 7-day delay provides a safety mechanism: deactivation becomes final only after 7 days, during which users can cancel via an ECDSA-signed transaction if they change their mind or detect an unauthorized deactivation attempt.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Parameters

| Constant                          | Value                |
|-----------------------------------|----------------------|
| `PRECOMPILE_ADDRESS`              | `0xTBD`              |
| `PRECOMPILE_GAS_COST`             | `13000`              |
| `CANCEL_PRECOMPILE_ADDRESS`       | `0xTBD`              |
| `CANCEL_PRECOMPILE_GAS_COST`      | `13000`              |
| `DEACTIVATION_DELAY`              | `604800` (7 days)    |

### Definitions

* `||` is the byte/byte-array concatenation operator.
* `deactivation_finalization_timestamp` is a per-account uint64 timestamp (seconds since Unix epoch) that specifies when a deactivation becomes final (7 days after initiation). If unset, no deactivation is scheduled.

### Delegated Code Encoding

The deactivation status is encoded by appending a `0x00` byte at the end of the delegated code. The encoding is as follows:

* Active state: `0xef0100 || address` (23 bytes). The private key is active and can sign transactions.
* Deactivated state: `0xef0100 || address || 0x00` (24 bytes). The private key is permanently deactivated and cannot sign transactions or [EIP-7702](./eip-7702) delegation authorizations.


### Client Code Recognition

Clients MUST recognize `0xef0100 || address || 0x00` as a valid delegated + deactivated account. The trailing `0x00` byte MUST be ignored for execution purposes—the EVM MUST still jump to `address` for code execution. This ensures that deactivated EOAs retain their delegated contract functionality.

### Deactivation Precompiled Contract

A new precompiled contract is introduced at address `PRECOMPILE_ADDRESS`. It costs `PRECOMPILE_GAS_COST` and executes the following logic:

* Returns a precompile contract error, consumes all gas, and no state changes are made if:
  * Gas is insufficient.
  * Called via `STATICCALL` (i.e., in a read-only context).
  * Caller is not an EOA with delegated code (prefix `0xef0100` as per [EIP-7702](./eip-7702)).
  * Caller's code length is not `23` bytes (already deactivated).
  * A deactivation is already scheduled for the caller (i.e., `deactivation_finalization_timestamp` is set).
* Behavior:
  * Computes `finalization_timestamp = block.timestamp + DEACTIVATION_DELAY` and sets `deactivation_finalization_timestamp` for the caller. The delegated code remains `23` bytes until finalization (7 days later).

### Cancellation Precompiled Contract

A new precompiled contract is introduced at address `CANCEL_PRECOMPILE_ADDRESS`. It costs `CANCEL_PRECOMPILE_GAS_COST` and allows cancellation of pending deactivations:

* Returns a precompile contract error, consumes all gas, and no state changes are made if:
  * Gas is insufficient.
  * Called via `STATICCALL` (i.e., in a read-only context).
  * Caller is not an EOA with delegated code (prefix `0xef0100` as per [EIP-7702](./eip-7702)).
  * No deactivation is scheduled for the caller (i.e., `deactivation_finalization_timestamp` is unset).
  * `block.timestamp >= deactivation_finalization_timestamp` (deactivation already finalized).
* Behavior:
  * Clears `deactivation_finalization_timestamp`, leaving the delegated code in the active 23-byte form.

### Finalization of Deactivations

For accounts with a scheduled deactivation (`deactivation_finalization_timestamp` set):

* During transaction validation, if `block.timestamp >= deactivation_finalization_timestamp`, the account MUST be treated as deactivated.
* Implementations MAY lazily append `0x00` to the delegated code and clear `deactivation_finalization_timestamp` upon the next state access, or MAY perform this conversion eagerly at block processing time.

### Transaction Validation

An account is considered deactivated if:
* Code prefix is `0xef0100` AND code length is `24` bytes, OR
* Code prefix is `0xef0100` AND `deactivation_finalization_timestamp` is set AND `block.timestamp >= deactivation_finalization_timestamp`

Validation to check whether a private key is deactivated MUST be performed in the following scenarios:

* During transaction validity checks before execution, nodes MUST reject transactions signed with deactivated private keys to ensure such transactions cannot be included in blocks.
* The same validation MUST be applied to the transaction pool when receiving new transactions to prevent invalid transactions from propagating through the network.
* Any [EIP-7702](./eip-7702) authorization issued by an authority with a deactivated private key MUST be treated as invalid and skipped.

### Mempool Behavior

Mempool implementations MUST adhere to the following rules:

* **Rejection of new transactions**: The mempool MUST reject newly received transactions from senders whose accounts are deactivated at the current head.
* **Eviction of existing transactions**: The mempool SHOULD evict already pooled transactions from a sender once that sender is observed deactivated at the current head.
* **Revalidation timing**: Mempool implementations MUST revalidate pooled transactions against the current head state on head changes. This MAY be done either:
  * Eagerly for affected senders upon head change, OR
  * Lazily when selecting transactions for propagation or block inclusion.

### Reorg Handling

On chain reorganization:

* The mempool SHOULD revalidate pooled transactions against the new head state.
* Transactions previously dropped due to deactivation MAY be re-accepted if re-gossiped after a reorg that undoes the deactivation.
* Implementations are NOT REQUIRED to retain transactions that became invalid due to deactivation across head changes—such transactions may need to be re-gossiped to re-enter the pool.

### Wallet and Indexer Parsing

Wallets and indexers SHOULD parse delegated EOA code as follows:

```python
def parse_delegated_eoa(code: bytes) -> dict:
    """
    Parse delegated EOA code to determine status.

    Returns:
        dict with keys:
        - 'is_delegated': bool
        - 'delegate_address': bytes or None
        - 'status': 'active' | 'deactivated' | 'unknown'
    """
    DELEGATION_PREFIX = bytes.fromhex("ef0100")

    if not code.startswith(DELEGATION_PREFIX):
        return {
            'is_delegated': False,
            'delegate_address': None,
            'status': 'unknown'
        }

    if len(code) == 23:
        # Active: 0xef0100 || address (20 bytes)
        return {
            'is_delegated': True,
            'delegate_address': code[3:23],
            'status': 'active'
        }
    elif len(code) == 24:
        # Deactivated: 0xef0100 || address || 0x00
        return {
            'is_delegated': True,
            'delegate_address': code[3:23],
            'status': 'deactivated'
        }
    else:
        return {
            'is_delegated': True,
            'delegate_address': code[3:23],
            'status': 'unknown'
        }
```

## Rationale

### Cost of Precompiled Contracts

The `PRECOMPILE_GAS_COST` represents the gas required to validate and potentially update an account's code. A fair cost for calling this precompiled contract can be determined by analyzing its impact on the node:

* Reading the code of the address: `2600`.
* Changing the code hash (from non-zero to non-zero): `5000`.
* Deploying at most `24` bytes of code: `200 * 24 = 4800`.

The primary operation consumes a total of `12400` gas, To account for additional overhead, such as context switching during state transitions, as well as code prefix and length validations, the cost is rounded up to 13000. The same cost applies to the cancellation precompile as the operations are symmetric.

### Additional Transaction Validation Overhead

Due to [EIP-3607](./eip-3607) and [EIP-7702](./eip-7702), nodes already load the account code during transaction validation to verify whether the sender is an EOA (empty code or code with prefix `0xef0100`). This EIP introduces only a code length check and a timestamp check, resulting in minimal additional overhead. Similarly, [EIP-7702](./eip-7702)'s authorization validation already involves retrieving the account code, with this EIP adding only a code length check and a timestamp check, which is negligible compared to code reading.

Transaction pools already perform state-based checks, such as those for nonce and balance. This EIP adds an account code read and a length check, which together are comparable to nonce and balance validations. DoS prevention mechanisms, expected in transaction pools, also support these additional checks.

### An Alternative EOA Deprecation Approach

An alternative deprecation approach involves using a hard fork to edit all existing and new EOAs to pre-written upgradeable smart contracts, which utilize the original EOA private key for authorization. Users can add and replace keys, or upgrade the smart contracts to other implementations. However, this approach is incompatible with EOAs already delegated to smart contracts, as it will overwrite the existing smart contract implementations. This EIP aims to fill this migration gap.

### Using a Precompiled Contract

Alternative methods for deactivating EOA private keys include:

* Adding a new transaction type: Introducing a new transaction type could provide a mechanism to deactivate EOA private keys. However, this adds complexity to transaction processing and validation.
* Deploying a smart contract: Compared to reusing the code field, using a smart contract has higher costs: (i) it requires new contract storage slots to track the deactivation status of each address (ii) executing bytecode increases the overhead of the node compared to precompiled contracts, (iii) during transaction validation, reusing the code field allows deactivation status check to be combined with existing code loading in some scenarios, thereby reducing the need for additional storage reads, as discussed in [Additional Transaction Validation Overhead](#additional-transaction-validation-overhead) section.

### One-Way Migration (No In-Protocol Reactivation)

This EIP intentionally does NOT provide an in-protocol reactivation mechanism. The rationale is:

* **Post-quantum security**: If a quantum attacker becomes viable, allowing ECDSA key reactivation would defeat the purpose of migration. A one-way deactivation provides strong guarantees against future quantum attacks.
* **Simplicity**: Removing reactivation significantly simplifies the protocol. Reactivation would require additional security measures at the delegated contract level to prevent unauthorized reactivation, which increases attack surface.
* **Clear security model**: Users have certainty that once deactivated, their ECDSA key cannot be used—even if the delegated contract is compromised in a way that would allow reactivation.

The 7-day delay provides a safety window for users who may have triggered deactivation accidentally or who detect an unauthorized deactivation attempt. During the delay period, the original ECDSA key can still cancel the deactivation.

### Avoiding Delegated Code Prefix Modification

This EIP appends a byte (`0x00`) to the delegated code instead of modifying the prefix (`0xef0100`) of [EIP-7702](./eip-7702) to ensure forward compatibility. If new prefixes such as `0xef0101` are introduced in the future, changing the prefix to represent the deactivated status (e.g., `0xef01ff`) makes it unclear which prefix to restore (`0xef0100` or `0xef0101`) upon reactivation.

### Avoiding Account State Changes

An alternative is to add a `deactivated` field in the account state to track the status. However, this approach will introduce backward compatibility logic and more test vectors related to this optional field when enabling this EIP, because the field is not present in existing accounts.

## Backwards Compatibility

When the private key is deactivated, this EIP introduces: (i) an extra byte (`0x00`) to be appended to the end of the delegated code, and (ii) the delegated code length becomes `24` bytes (e.g., `EXTCODESIZE` would return `24`). The delegated code does not change until the 7-day delay period has passed.

These changes are not breaking. However, they require protocol, application, and contract implementations to use strict offsets to parse the delegated address correctly. Implementations must also check the delegated code prefix `0xef0100` to determine whether it represents an EOA with delegated code, while avoiding over-restrictive checks, such as asserting the code length to be exactly `23`.

Clients MUST still jump to the delegated address for execution even when the trailing byte is present—the deactivation status only affects ECDSA signing authority, not contract execution.

## Test Cases

```python
# Initialize the state database and precompiled contracts
state_db = StateDB()
deactivate_precompile = DeactivationPrecompile()
cancel_precompile = CancellationPrecompile()

delegated_addr = bytes.fromhex("1122334455667788990011223344556677889900")
active_code = DeactivationPrecompile.DELEGATED_CODE_PREFIX + delegated_addr  # Active state (23 bytes)
current_timestamp = 1700000000

# Test 1: Deactivation schedules 7-day delay
caller = "0x0123"
state_db.set_code(caller, active_code)
error, gas_left = deactivate_precompile.execute(caller, state_db, gas=15000, block_timestamp=current_timestamp)
assert error == b""
expected_timestamp = current_timestamp + 604800  # 7 days
assert state_db.get_code(caller) == active_code  # Still active during delay
assert state_db.get_deactivation_timestamp(caller) == expected_timestamp
assert gas_left == 15000 - DeactivationPrecompile.PRECOMPILE_GAS_COST

# Test 2: Cannot schedule deactivation twice
error, gas_left = deactivate_precompile.execute(caller, state_db, gas=15000, block_timestamp=current_timestamp)
assert error == b"account already has a scheduled deactivation"
assert gas_left == 0

# Test 3: Cancel deactivation during delay period
error, gas_left = cancel_precompile.execute(caller, state_db, gas=15000, block_timestamp=current_timestamp + 1000)
assert error == b""
assert state_db.get_deactivation_timestamp(caller) is None
assert state_db.get_code(caller) == active_code  # Back to active state (23 bytes)

# Test 4: Deactivation finalizes after 7 days
caller2 = "0x4567"
state_db.set_code(caller2, active_code)
deactivate_precompile.execute(caller2, state_db, gas=15000, block_timestamp=current_timestamp)
finalization_timestamp = state_db.get_deactivation_timestamp(caller2)
assert is_account_deactivated(state_db.get_code(caller2), finalization_timestamp - 1, finalization_timestamp) is False
assert is_account_deactivated(state_db.get_code(caller2), finalization_timestamp + 1, finalization_timestamp) is True

# Test 5: Cannot cancel after finalization
error, gas_left = cancel_precompile.execute(
    caller2, state_db, gas=15000, block_timestamp=finalization_timestamp + 1
)
assert error == b"deactivation already finalized"
assert gas_left == 0

# Test 6: Error cases
caller3 = "0xcdef"  # EOA that is not delegated to code
error, gas_left = deactivate_precompile.execute(caller3, state_db, gas=15000, block_timestamp=current_timestamp)
assert error == b"the address is not an EOA delegated to code"
assert gas_left == 0

error, gas_left = deactivate_precompile.execute(caller, state_db, gas=15000, read_only=True)
assert error == b"STATICCALL disallows state modification"
assert gas_left == 0

error, gas_left = deactivate_precompile.execute(caller, state_db, gas=DeactivationPrecompile.PRECOMPILE_GAS_COST - 1)
assert error == b"insufficient gas"
assert gas_left == 0
```

## Reference Implementation

```python
class DeactivationPrecompile:
    DELEGATED_CODE_PREFIX = bytes.fromhex("ef0100")
    PRECOMPILE_GAS_COST = 13000
    DEACTIVATION_DELAY = 604800  # 7 days in seconds

    def execute(self, caller, state_db, gas, read_only=False, block_timestamp=0):
        """
        Schedule deactivation of the private key of a delegated EOA with a 7-day delay.

        Parameters:
        - caller: The address calling the contract
        - state_db: The state database
        - gas: Gas provided for execution
        - read_only: Whether called in a read-only context
        - block_timestamp: Current block timestamp

        Returns:
        - Tuple of (result, gas_left)
          result: error bytes on failure, empty bytes on success
          gas_left: remaining gas, 0 on error
        """
        if gas < self.PRECOMPILE_GAS_COST:
            return b"insufficient gas", 0

        if read_only:
            return b"STATICCALL disallows state modification", 0

        code = state_db.get_code(caller)
        if not code.startswith(self.DELEGATED_CODE_PREFIX):
            return b"the address is not an EOA delegated to code", 0

        if len(code) != 23:
            return b"account is not in active state", 0

        existing_finalization_timestamp = state_db.get_deactivation_timestamp(caller)
        if existing_finalization_timestamp is not None:
            if block_timestamp >= existing_finalization_timestamp:
                return b"account is not in active state", 0
            return b"account already has a scheduled deactivation", 0

        # Schedule 7-day delayed deactivation
        finalization_timestamp = block_timestamp + self.DEACTIVATION_DELAY
        state_db.set_deactivation_timestamp(caller, finalization_timestamp)

        return b"", gas - self.PRECOMPILE_GAS_COST


class CancellationPrecompile:
    DELEGATED_CODE_PREFIX = bytes.fromhex("ef0100")
    PRECOMPILE_GAS_COST = 13000

    def execute(self, caller, state_db, gas, read_only=False, block_timestamp=0):
        """
        Cancel a pending deactivation of a delegated EOA.

        Parameters:
        - caller: The address calling the contract
        - state_db: The state database
        - gas: Gas provided for execution
        - read_only: Whether called in a read-only context
        - block_timestamp: Current block timestamp

        Returns:
        - Tuple of (result, gas_left)
          result: error bytes on failure, empty bytes on success
          gas_left: remaining gas, 0 on error
        """
        if gas < self.PRECOMPILE_GAS_COST:
            return b"insufficient gas", 0

        if read_only:
            return b"STATICCALL disallows state modification", 0

        code = state_db.get_code(caller)
        if not code.startswith(self.DELEGATED_CODE_PREFIX):
            return b"the address is not an EOA delegated to code", 0

        finalization_timestamp = state_db.get_deactivation_timestamp(caller)
        if finalization_timestamp is None:
            return b"account has no scheduled deactivation", 0

        # Check if deactivation has already finalized
        if block_timestamp >= finalization_timestamp:
            return b"deactivation already finalized", 0

        # Cancel: clear the scheduled deactivation
        state_db.clear_deactivation_timestamp(caller)

        return b"", gas - self.PRECOMPILE_GAS_COST


class StateDB:
    """Simplified state database, omitting other account fields"""
    def __init__(self):
        self.accounts = {}

    def get_code(self, addr):
        return self.accounts.get(addr, {}).get("code", b"")

    def set_code(self, addr, value):
        if addr not in self.accounts:
            self.accounts[addr] = {}
        self.accounts[addr]["code"] = value

    def get_deactivation_timestamp(self, addr):
        return self.accounts.get(addr, {}).get("deactivation_finalization_timestamp")

    def set_deactivation_timestamp(self, addr, value):
        if addr not in self.accounts:
            self.accounts[addr] = {}
        self.accounts[addr]["deactivation_finalization_timestamp"] = value

    def clear_deactivation_timestamp(self, addr):
        if addr in self.accounts:
            self.accounts[addr].pop("deactivation_finalization_timestamp", None)


def is_account_deactivated(code: bytes, block_timestamp: int, finalization_timestamp: int | None = None) -> bool:
    """
    Check if an account is deactivated based on its code and current timestamp.

    Parameters:
    - code: The account's code
    - block_timestamp: Current block timestamp
    - finalization_timestamp: Optional delayed deactivation timestamp

    Returns:
    - True if deactivated, False otherwise
    """
    DELEGATED_CODE_PREFIX = bytes.fromhex("ef0100")

    if not code.startswith(DELEGATED_CODE_PREFIX):
        return False

    if len(code) == 24:
        # Deactivated (code has been finalized)
        return True
    elif len(code) == 23 and finalization_timestamp is not None:
        # Pending deactivation - check if 7-day delay has passed
        return block_timestamp >= finalization_timestamp

    return False
```

## Security Considerations

### Contracts Using ECDSA `Secp256k1` Signatures

Contracts that have already been deployed and use ECDSA `secp256k1` signatures outside of transaction signatures (e.g., [ERC-20](./eip-20) tokens that support [ERC-2612](./eip-2612), the `permit` function) will not be able to verify the deactivated status of the EOA. This means that signatures signed by private keys will remain valid in these functions.

To handle deactivated EOAs, new or upgradeable contracts can check the signing address's deactivation status, for example:

* Use `EXTCODESIZE` to get the account's code length.
* If the code length is `24` bytes, use `EXTCODECOPY` to verify the code starts with `0xef0100` (delegated code prefix).
* For 24-byte code: the account is deactivated.

Delayed deactivation scheduling is not encoded in the delegated code, so contracts cannot detect a scheduled (but not yet finalized) deactivation without additional protocol support.

For non-upgradeable contracts, the above method cannot be applied directly. The only clear path available, at the protocol level, is to modify `ecRecover` precompiled contract: if the private key of the recovered address is deactivated, the `ecRecover` precompiled contract could return a precompile contract error (or, if not adding an error return path, return a zero address or a collision-resistant address, such as `0x1`). This is why this EIP requires [EIP-XXXX](./eip-XXXX) to mitigate the ecRecover related risks.  

### Irreversible Deactivation by Design

Deactivation is intentionally irreversible at the protocol level to provide post-quantum security guarantees. Users should understand that once the 7-day delay period has passed, their ECDSA key cannot be reactivated. The 7-day delay provides a safety window for users to cancel if needed.

### 7-Day Delay Security

The 7-day delay mechanism introduces additional considerations:

* **Cancellation window**: During the 7-day delay period, the original ECDSA key can cancel the deactivation. This is intentional—it provides a safety mechanism against unauthorized deactivation attempts.
* **Malicious cancellation**: If an attacker has access to the ECDSA key during the delay period, they can cancel the deactivation. Users who suspect key compromise should take immediate action to secure their account through other means.

### Deactivation Replay Protection

For deactivation through EOA-signed transactions, the use of nonces in transactions ensures the same message cannot be replayed multiple times on the same chain. Additionally, the replay protection mechanism provided by [EIP-155](./eip-155), if enabled, effectively prevents cross-chain message replay.

For deactivation via delegated contracts, the contract should implement robust replay protection mechanism(s) (e.g., adding a customized nonce and the chain ID to the signed message) to safeguard against replay attacks both within the same chain and across different chains. Especially when the EOA has been (or will be) delegated to the same implementation on multiple chains.

### Mempool and Reorg Considerations

* **Mempool eviction timing**: Implementations should be aware that evicting transactions immediately upon deactivation may cause issues if the deactivation is reverted in a reorg. The SHOULD (rather than MUST) language for eviction provides flexibility.
* **Revalidation overhead**: Frequent head changes require revalidation. Implementations should balance thoroughness with performance.
* **Pending deactivation edge cases**: Transactions from accounts with a scheduled deactivation remain valid until `block.timestamp >= deactivation_finalization_timestamp`. Implementations must track this correctly across block boundaries.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
